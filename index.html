import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ScatterChart, Scatter, LineChart, Line, PieChart, Pie, Cell, ZAxis } from 'recharts';
import { LayoutDashboard, DollarSign, TrendingUp, MapPin, Briefcase, Building, Network, Wrench, GraduationCap, BarChart2, Globe, Factory, Medal, FileText, Info, FileJson } from 'lucide-react';

// CSV Data URL - Corrected to the valid raw content URL.
const DATA_URL = 'https://raw.githubusercontent.com/joe-shenouda/dev-temp/main/ai_job_dataset.csv';

// --- Helper Functions ---

/**
 * A robust, state-machine-based CSV parser that correctly handles
 * newlines and commas within quoted fields. This is essential for
 * parsing complex CSVs like the one used in this project.
 * @param {string} csvText - The raw CSV string.
 * @returns {Array<Object>} An array of job data objects.
 */
const parseCSV = (csvText) => {
    const rows = [];
    let currentRow = [];
    let currentField = '';
    let inQuotes = false;
    // Add a newline to the end to ensure the last row is processed.
    const text = csvText.trim() + '\n';

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        
        if (inQuotes) {
            if (char === '"') {
                if (text[i + 1] === '"') { // Handle escaped double quotes ""
                    currentField += '"';
                    i++; // Skip the next character
                } else {
                    inQuotes = false;
                }
            } else {
                currentField += char;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                currentRow.push(currentField);
                currentField = '';
            } else if (char === '\n' || char === '\r') {
                // End of a row
                if (i > 0 && text[i-1] !== '\n' && text[i-1] !== '\r') {
                    currentRow.push(currentField);
                    rows.push(currentRow);
                    currentRow = [];
                    currentField = '';
                }
                 // handle CRLF by skipping LF if previous was CR
                if (char === '\r' && text[i+1] === '\n') {
                    i++;
                }
            } else {
                currentField += char;
            }
        }
    }
    
    if (rows.length < 2) {
        console.error("CSV parsing failed or resulted in insufficient data.");
        return [];
    }

    const headers = rows[0].map(h => h.trim());
    const data = [];

    for (let i = 1; i < rows.length; i++) {
        if (rows[i].length === headers.length) {
            let rowObject = {};
            headers.forEach((header, index) => {
                const valueStr = rows[i][index];
                if (!isNaN(valueStr) && valueStr.trim() !== '' && !isNaN(parseFloat(valueStr))) {
                    rowObject[header] = Number(valueStr);
                } else {
                    rowObject[header] = valueStr;
                }
            });
            data.push(rowObject);
        }
    }

    return data;
};


// --- Formatting and Mapping Helpers ---
const formatCurrency = (value) => {
    if (isNaN(value) || value === null) return 'N/A';
    return new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD', minimumFractionDigits: 0 }).format(value);
}
const experienceMapping = { 'EN': 'Entry', 'MI': 'Mid-Level', 'SE': 'Senior', 'EX': 'Executive' };
const experienceOrder = { 'Entry': 1, 'Mid-Level': 2, 'Senior': 3, 'Executive': 4 };
const employmentTypeMapping = { 'FT': 'Full-time', 'PT': 'Part-time', 'CT': 'Contract', 'FL': 'Freelance' };
const companySizeMapping = { 'S': 'Small (<50)', 'M': 'Medium (50-250)', 'L': 'Large (>250)' };
const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#AF19FF'];
const EXP_COLORS = { 'Entry': '#2ecc71', 'Mid-Level': '#3498db', 'Senior': '#e74c3c', 'Executive': '#9b59b6'};


// --- Main App Component ---
export default function App() {
    const [data, setData] = useState([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    const [activeView, setActiveView] = useState('overview');

    // Effect to fetch and parse data on component mount.
    useEffect(() => {
        const fetchData = async () => {
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}. Failed to fetch data from the source.`);
                }
                const csvText = await response.text();
                
                const parsedData = parseCSV(csvText).map(d => ({
                    ...d,
                    experience_level_full: experienceMapping[d.experience_level] || 'Unknown',
                    employment_type_full: employmentTypeMapping[d.employment_type] || 'Unknown',
                    company_size_full: companySizeMapping[d.company_size] || 'Unknown',
                    posting_date: d.posting_date ? new Date(d.posting_date) : null,
                }));
                
                if(parsedData.length === 0){
                   console.error("Parsing resulted in an empty dataset. Please check the CSV file and parser logic.");
                   throw new Error("Failed to parse CSV data correctly. The dataset is empty.");
                }

                setData(parsedData);
            } catch (e) {
                console.error("Fetch or Parse error:", e);
                setError(e.message);
            } finally {
                setLoading(false);
            }
        };
        fetchData();
    }, []);

    // Menu items for the sidebar navigation.
    const menuItems = [
        { id: 'overview', label: 'Overview', icon: LayoutDashboard },
        { id: 'salaryAnalysis', label: 'Salary Analysis', icon: DollarSign },
        { id: 'topPayingJobs', label: 'Top Paying Jobs', icon: Medal },
        { id: 'marketTrends', label: 'Market Trends', icon: TrendingUp },
        { id: 'geographicAnalysis', label: 'Geographic Analysis', icon: MapPin },
        { id: 'countrySpecific', label: 'Country Specific', icon: Globe },
        { id: 'experienceLevel', label: 'By Experience Level', icon: Briefcase },
        { id: 'companyInsights', label: 'By Company Size', icon: Building },
        { id: 'industryBreakdown', label: 'By Industry', icon: Factory },
        { id: 'remoteWork', label: 'Remote Work', icon: Network },
        { id: 'skillsDemand', label: 'Skills Demand', icon: Wrench },
        { id: 'jobCategories', label: 'By Job Category', icon: BarChart2 },
        { id: 'salaryVsExperience', label: 'Salary vs. Experience', icon: GraduationCap },
        { id: 'jobDescLength', label: 'Description Length', icon: FileText },
        { id: 'benefitsAnalysis', label: 'Benefits Analysis', icon: Medal },
        { id: 'aboutDataset', label: 'About Dataset', icon: FileJson },
        { id: 'about', label: 'About App', icon: Info },
    ];

    // Renders the main content based on the active view.
    const renderContent = () => {
        if (loading) return <div className="flex items-center justify-center h-full"><div className="text-xl font-semibold text-gray-500">Loading Dashboard Data...</div></div>;
        if (error) return <div className="flex flex-col items-center justify-center h-full p-4"><div className="text-xl font-semibold text-red-500">Error Loading Data</div><p className="text-center text-red-400 mt-2">{error}</p><p className="mt-4 text-center text-sm bg-yellow-100 p-2 rounded-md">Please check the browser's developer console (F12) for more details. Ensure you have a stable internet connection and that the data URL is correct.</p></div>;
        if (data.length === 0) return <div className="flex items-center justify-center h-full"><div className="text-xl font-semibold text-gray-500">No data found after processing. Please check the data source and format.</div></div>

        switch (activeView) {
            case 'overview': return <Overview data={data} />;
            case 'salaryAnalysis': return <SalaryAnalysis data={data} />;
            case 'marketTrends': return <MarketTrends data={data} />;
            case 'geographicAnalysis': return <GeographicAnalysis data={data} />;
            case 'experienceLevel': return <ExperienceLevelAnalysis data={data} />;
            case 'companyInsights': return <CompanyInsights data={data} />;
            case 'remoteWork': return <RemoteWorkAnalysis data={data} />;
            case 'skillsDemand': return <SkillsDemandAnalysis data={data} />;
            case 'jobCategories': return <JobCategoryAnalysis data={data} />;
            case 'salaryVsExperience': return <SalaryVsYearsExperience data={data} />;
            case 'topPayingJobs': return <TopPayingJobs data={data} />;
            case 'countrySpecific': return <CountrySpecificAnalysis data={data} />;
            case 'industryBreakdown': return <IndustryBreakdown data={data} />;
            case 'benefitsAnalysis': return <BenefitsAnalysis data={data} />;
            case 'jobDescLength': return <JobDescLengthAnalysis data={data} />;
            case 'aboutDataset': return <AboutDataset />;
            case 'about': return <About />;
            default: return <Overview data={data} />;
        }
    };

    return (
        <div className="flex h-screen bg-gray-100 font-sans">
            <aside className="w-64 bg-gray-800 text-white flex-shrink-0 overflow-y-auto">
                <div className="p-4 text-2xl font-bold border-b border-gray-700">AI Jobs Dashboard</div>
                <nav className="mt-4">
                    <ul>
                        {menuItems.map(item => (
                            <li key={item.id} className={`mx-2 my-1 rounded-md transition-colors ${activeView === item.id ? 'bg-blue-600' : 'hover:bg-gray-700'}`}>
                                <a href="#" className="flex items-center p-3" onClick={(e) => { e.preventDefault(); setActiveView(item.id); }}>
                                    <item.icon className="h-5 w-5 mr-3" />
                                    <span>{item.label}</span>
                                </a>
                            </li>
                        ))}
                    </ul>
                </nav>
            </aside>
            <main className="flex-1 p-6 overflow-y-auto">
                <h1 className="text-3xl font-bold text-gray-800 mb-6">{menuItems.find(item => item.id === activeView)?.label}</h1>
                <div className="h-[calc(100%-54px)]">
                    {renderContent()}
                </div>
            </main>
        </div>
    );
}

// --- Reusable Components ---
const Card = ({ title, value, subtext }) => (
    <div className="bg-white p-6 rounded-lg shadow-md">
        <h3 className="text-sm font-medium text-gray-500">{title}</h3>
        <p className="text-3xl font-bold text-gray-800 mt-2">{value || 'N/A'}</p>
        {subtext && <p className="text-sm text-gray-400 mt-1">{subtext}</p>}
    </div>
);

const ChartContainer = ({ title, children }) => (
    <div className="bg-white p-6 rounded-lg shadow-md mt-6">
        <h3 className="text-lg font-semibold text-gray-700 mb-4">{title}</h3>
        <div className="h-96"> {/* Increased height for better visibility */}
            {children}
        </div>
    </div>
);

// --- Individual View Components ---

const Overview = ({ data }) => {
    // Memoized calculation for key performance indicators.
    const metrics = useMemo(() => {
        if (!data || data.length === 0) return {};
        const totalJobs = data.length;
        const salaries = data.map(d => d.salary_usd).filter(s => s && s > 0);
        const avgSalary = salaries.reduce((acc, curr) => acc + curr, 0) / salaries.length;
        const uniqueCountries = new Set(data.map(d => d.company_location)).size;
        const fullyRemote = data.filter(d => d.remote_ratio === 100).length;
        return {
            totalJobs: totalJobs.toLocaleString(),
            avgSalary: formatCurrency(avgSalary),
            uniqueCountries: uniqueCountries.toLocaleString(),
            fullyRemote: `${((fullyRemote / totalJobs) * 100).toFixed(1)}%`,
        };
    }, [data]);

    // Memoized calculation for salary by experience level.
    const salaryByExperience = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.experience_level_full || !d.salary_usd) return;
            const level = d.experience_level_full;
            if (!result[level]) result[level] = { total: 0, count: 0 };
            result[level].total += d.salary_usd;
            result[level].count += 1;
        });
        return Object.entries(result).map(([name, { total, count }]) => ({ name, 'Average Salary': Math.round(total / count) }))
            .sort((a,b) => experienceOrder[a.name] - experienceOrder[b.name]);
    }, [data]);

    // Memoized calculation for top job categories.
    const jobsByCategory = useMemo(() => {
        const counts = data.reduce((acc, curr) => {
            if (curr.job_category && curr.job_category !== 'N/A') {
                acc[curr.job_category] = (acc[curr.job_category] || 0) + 1;
            }
            return acc;
        }, {});
        return Object.entries(counts).map(([name, value]) => ({ name, value })).sort((a,b) => b.value - a.value).slice(0, 5);
    }, [data]);

    return (
        <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-6">
            <Card title="Total Job Postings" value={metrics.totalJobs} />
            <Card title="Average Salary (USD)" value={metrics.avgSalary} />
            <Card title="Locations (Countries)" value={metrics.uniqueCountries} />
            <Card title="Fully Remote" value={metrics.fullyRemote} subtext="Percentage of jobs" />
            
            <div className="md:col-span-2 xl:col-span-2">
                 <ChartContainer title="Average Salary by Experience Level">
                    <ResponsiveContainer width="100%" height="100%">
                        <BarChart data={salaryByExperience} layout="vertical" margin={{ top: 5, right: 30, left: 50, bottom: 5 }}>
                            <CartesianGrid strokeDasharray="3 3" />
                            <XAxis type="number" tickFormatter={formatCurrency} />
                            <YAxis type="category" dataKey="name" width={100} />
                            <Tooltip formatter={(value) => formatCurrency(value)} />
                            <Legend />
                            <Bar dataKey="Average Salary" fill="#8884d8" />
                        </BarChart>
                    </ResponsiveContainer>
                </ChartContainer>
            </div>

            <div className="md:col-span-2 xl:col-span-2">
                <ChartContainer title="Top 5 Job Categories">
                     <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                            <Pie data={jobsByCategory} cx="50%" cy="50%" labelLine={false} label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`} outerRadius={120} fill="#8884d8" dataKey="value">
                                {jobsByCategory.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                ))}
                            </Pie>
                             <Tooltip formatter={(value, name) => [value.toLocaleString(), name]}/>
                             <Legend/>
                        </PieChart>
                    </ResponsiveContainer>
                </ChartContainer>
            </div>
        </div>
    );
};

const SalaryAnalysis = ({ data }) => {
    const salaryByCountry = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.company_location || !d.salary_usd) return;
            const country = d.company_location;
            if (!result[country]) result[country] = { total: 0, count: 0 };
            result[country].total += d.salary_usd;
            result[country].count += 1;
        });
        return Object.entries(result).map(([name, { total, count }]) => ({ name, 'Average Salary': Math.round(total / count), 'Job Count': count })).filter(d => d['Job Count'] > 50).sort((a,b) => b['Average Salary'] - a['Average Salary']).slice(0, 10);
    }, [data]);
    
    const salaryByCompanySize = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.company_size_full || !d.salary_usd) return;
            const size = d.company_size_full;
            if (!result[size]) result[size] = { total: 0, count: 0 };
            result[size].total += d.salary_usd;
            result[size].count += 1;
        });
        return Object.entries(result).map(([name, { total, count }]) => ({ name, 'Average Salary': Math.round(total / count) })).sort((a, b) => a.name.length - b.name.length);
    }, [data]);

    return (
        <div className="space-y-6">
            <ChartContainer title="Top 10 Highest Paying Countries (min. 50 jobs)">
                <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={salaryByCountry} margin={{ top: 5, right: 30, left: 20, bottom: 60 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="name" angle={-45} textAnchor="end" />
                        <YAxis tickFormatter={formatCurrency}/>
                        <Tooltip formatter={(value) => formatCurrency(value)}/>
                        <Legend />
                        <Bar dataKey="Average Salary" fill="#82ca9d" />
                    </BarChart>
                </ResponsiveContainer>
            </ChartContainer>
            <ChartContainer title="Average Salary by Company Size">
                <ResponsiveContainer width="100%" height="100%">
                   <BarChart data={salaryByCompanySize} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="name" />
                        <YAxis tickFormatter={formatCurrency}/>
                        <Tooltip formatter={(value) => formatCurrency(value)}/>
                        <Legend />
                        <Bar dataKey="Average Salary" fill="#ffc658" />
                    </BarChart>
                </ResponsiveContainer>
            </ChartContainer>
        </div>
    )
}

const TopPayingJobs = ({ data }) => {
    const topJobs = useMemo(() => {
        const jobs = {};
        data.forEach(d => {
            if (!d.job_title || !d.salary_usd) return;
            if (!jobs[d.job_title]) {
                jobs[d.job_title] = { totalSalary: 0, count: 0 };
            }
            jobs[d.job_title].totalSalary += d.salary_usd;
            jobs[d.job_title].count++;
        });

        return Object.entries(jobs)
            .map(([title, { totalSalary, count }]) => ({
                title,
                count,
                'Average Salary': Math.round(totalSalary / count),
            }))
            .filter(j => j.count > 10) // Only include jobs with more than 10 postings
            .sort((a, b) => b['Average Salary'] - a['Average Salary'])
            .slice(0, 15);
    }, [data]);

    return (
        <ChartContainer title="Top 15 Highest Paying Job Titles (min. 10 postings)">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={topJobs} layout="vertical" margin={{ top: 5, right: 30, left: 150, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis type="number" tickFormatter={formatCurrency} />
                    <YAxis type="category" dataKey="title" width={150} tick={{ fontSize: 12 }} />
                    <Tooltip formatter={(value, name) => name === "Average Salary" ? formatCurrency(value) : value.toLocaleString()} />
                    <Legend />
                    <Bar dataKey="Average Salary" fill="#d0abf9" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const MarketTrends = ({ data }) => {
    const trendsData = useMemo(() => {
        const monthlyData = {};
        data.filter(d => d.posting_date).forEach(d => {
            const month = d.posting_date.toISOString().slice(0, 7); // YYYY-MM
            if (!monthlyData[month]) {
                monthlyData[month] = { count: 0, totalSalary: 0 };
            }
            monthlyData[month].count++;
            monthlyData[month].totalSalary += d.salary_usd;
        });
        
        return Object.entries(monthlyData).map(([month, values]) => ({
            month,
            'Job Postings': values.count,
            'Average Salary': Math.round(values.totalSalary / values.count)
        })).sort((a, b) => a.month.localeCompare(b.month));
    }, [data]);

    return (
        <div className="space-y-6">
            <ChartContainer title="Job Postings Over Time">
                <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={trendsData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="month" />
                        <YAxis />
                        <Tooltip />
                        <Legend />
                        <Line type="monotone" dataKey="Job Postings" stroke="#8884d8" activeDot={{ r: 8 }} />
                    </LineChart>
                </ResponsiveContainer>
            </ChartContainer>
            <ChartContainer title="Average Salary Over Time">
                <ResponsiveContainer width="100%" height="100%">
                    <LineChart data={trendsData} margin={{ top: 5, right: 30, left: 20, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="month" />
                        <YAxis yAxisId="left" tickFormatter={formatCurrency} />
                        <Tooltip formatter={(value) => formatCurrency(value)} />
                        <Legend />
                        <Line yAxisId="left" type="monotone" dataKey="Average Salary" stroke="#82ca9d" />
                    </LineChart>
                </ResponsiveContainer>
            </ChartContainer>
        </div>
    );
};

const GeographicAnalysis = ({ data }) => {
    const jobsByCountry = useMemo(() => {
        const counts = data.reduce((acc, curr) => {
             if(!curr.company_location) return acc;
            acc[curr.company_location] = (acc[curr.company_location] || 0) + 1;
            return acc;
        }, {});
        return Object.entries(counts).map(([name, value]) => ({ name, value })).sort((a,b) => b.value - a.value).slice(0, 15);
    }, [data]);

     return (
        <ChartContainer title="Top 15 Countries by Job Postings">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={jobsByCountry} layout="vertical" margin={{ top: 5, right: 30, left: 50, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis type="number" />
                    <YAxis type="category" dataKey="name" width={80}/>
                    <Tooltip />
                    <Legend />
                    <Bar dataKey="value" name="Job Count" fill="#3498db" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const CountrySpecificAnalysis = ({ data }) => {
    const [selectedCountry, setSelectedCountry] = useState('United States');
    
    const countries = useMemo(() => {
        const countryCounts = data.reduce((acc, curr) => {
            if (curr.company_location) {
                acc[curr.company_location] = (acc[curr.company_location] || 0) + 1;
            }
            return acc;
        }, {});
        return Object.entries(countryCounts)
            .sort((a, b) => b[1] - a[1])
            .map(entry => entry[0]);
    }, [data]);

    const countryData = useMemo(() => {
        if (!selectedCountry) return null;
        const filteredData = data.filter(d => d.company_location === selectedCountry);
        if (filteredData.length === 0) return { metrics: {}, expData: [] };
        
        const totalJobs = filteredData.length;
        const salaries = filteredData.map(d => d.salary_usd).filter(s => s > 0);
        const avgSalary = salaries.reduce((acc, curr) => acc + curr, 0) / salaries.length;

        const result = {};
        filteredData.forEach(d => {
            if (!d.experience_level_full || !d.salary_usd) return;
            const level = d.experience_level_full;
            if (!result[level]) result[level] = { total: 0, count: 0 };
            result[level].total += d.salary_usd;
            result[level].count += 1;
        });
        const expData = Object.entries(result).map(([name, { total, count }]) => ({ name, 'Average Salary': Math.round(total / count) }))
            .sort((a,b) => experienceOrder[a.name] - experienceOrder[b.name]);

        return {
            metrics: {
                totalJobs: totalJobs.toLocaleString(),
                avgSalary: formatCurrency(avgSalary),
            },
            expData,
        };
    }, [selectedCountry, data]);

    return (
        <div className="bg-white p-6 rounded-lg shadow-md">
            <div className="flex items-center mb-4">
                <label htmlFor="country-select" className="mr-2 font-semibold">Select a Country:</label>
                <select id="country-select" value={selectedCountry} onChange={e => setSelectedCountry(e.target.value)}
                    className="p-2 border rounded-md shadow-sm">
                    {countries.map(c => <option key={c} value={c}>{c}</option>)}
                </select>
            </div>
            
            {selectedCountry && countryData && (
                <div>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
                        <Card title={`Total Jobs in ${selectedCountry}`} value={countryData.metrics.totalJobs} />
                        <Card title={`Average Salary in ${selectedCountry}`} value={countryData.metrics.avgSalary} />
                    </div>
                     <ChartContainer title={`Average Salary by Experience in ${selectedCountry}`}>
                        <ResponsiveContainer width="100%" height="100%">
                            <BarChart data={countryData.expData}>
                                <CartesianGrid strokeDasharray="3 3" />
                                <XAxis dataKey="name" />
                                <YAxis tickFormatter={formatCurrency} />
                                <Tooltip formatter={(value) => formatCurrency(value)} />
                                <Legend />
                                <Bar dataKey="Average Salary" fill="#1abc9c" />
                            </BarChart>
                        </ResponsiveContainer>
                    </ChartContainer>
                </div>
            )}
        </div>
    );
};

const ExperienceLevelAnalysis = ({ data }) => {
    const dataByExperience = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.experience_level_full || !d.salary_usd) return;
            const level = d.experience_level_full;
            if (!result[level]) result[level] = { totalSalary: 0, count: 0, remoteCount: 0 };
            result[level].totalSalary += d.salary_usd;
            result[level].count++;
            if (d.remote_ratio === 100) result[level].remoteCount++;
        });
        return Object.entries(result).map(([name, values]) => ({ 
            name, 
            'Average Salary': Math.round(values.totalSalary / values.count),
            'Job Count': values.count,
            'Remote Percentage': (values.remoteCount / values.count * 100).toFixed(1)
        })).sort((a,b) => experienceOrder[a.name] - experienceOrder[b.name]);
    }, [data]);

    return (
        <ChartContainer title="Analysis by Experience Level">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={dataByExperience}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis yAxisId="left" orientation="left" stroke="#8884d8" tickFormatter={formatCurrency}/>
                    <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" />
                    <Tooltip formatter={(value, name) => name === "Average Salary" ? formatCurrency(value) : (name === 'Remote Percentage' ? `${value}%` : value.toLocaleString())}/>
                    <Legend />
                    <Bar yAxisId="left" dataKey="Average Salary" fill="#8884d8" />
                    <Bar yAxisId="right" dataKey="Job Count" fill="#82ca9d" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const CompanyInsights = ({ data }) => {
    const statsBySize = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.company_size_full || !d.salary_usd) return;
            const size = d.company_size_full;
            if (!result[size]) result[size] = { totalSalary: 0, count: 0, remoteCount: 0 };
            result[size].totalSalary += d.salary_usd;
            result[size].count++;
            if (d.remote_ratio === 100) result[size].remoteCount++;
        });
        return Object.entries(result).map(([name, values]) => ({ 
            name, 
            'Average Salary': Math.round(values.totalSalary / values.count),
            'Job Count': values.count,
        })).sort((a,b) => a.name.length - b.name.length);
    }, [data]);

    return (
        <ChartContainer title="Company Size Insights">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={statsBySize}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis yAxisId="left" orientation="left" stroke="#8884d8" tickFormatter={formatCurrency}/>
                    <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" />
                    <Tooltip formatter={(value, name) => name === "Average Salary" ? formatCurrency(value) : value.toLocaleString()}/>
                    <Legend />
                    <Bar yAxisId="left" dataKey="Average Salary" fill="#8884d8" />
                    <Bar yAxisId="right" dataKey="Job Count" fill="#82ca9d" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const IndustryBreakdown = ({ data }) => {
    const industryStats = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.industry || d.industry === 'N/A' || !d.salary_usd) return;
            const industry = d.industry;
            if (!result[industry]) {
                result[industry] = { totalSalary: 0, count: 0 };
            }
            result[industry].totalSalary += d.salary_usd;
            result[industry].count++;
        });

        return Object.entries(result)
            .map(([name, { totalSalary, count }]) => ({
                name,
                'Job Count': count,
                'Average Salary': Math.round(totalSalary / count),
            }))
            .filter(item => item['Job Count'] > 20) // Filter for industries with a significant number of jobs
            .sort((a, b) => b['Job Count'] - a['Job Count'])
            .slice(0, 15);
    }, [data]);

    return (
        <div className="space-y-6">
            <ChartContainer title="Top 15 Industries by Job Count (min. 20 jobs)">
                <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={industryStats} layout="vertical" margin={{ top: 5, right: 30, left: 150, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis type="number" />
                        <YAxis type="category" dataKey="name" width={150} tick={{ fontSize: 12 }} />
                        <Tooltip formatter={(value) => value.toLocaleString()} />
                        <Legend />
                        <Bar dataKey="Job Count" fill="#f39c12" />
                    </BarChart>
                </ResponsiveContainer>
            </ChartContainer>
            <ChartContainer title="Average Salary by Top Industries">
                <ResponsiveContainer width="100%" height="100%">
                    <BarChart data={[...industryStats].sort((a,b) => b['Average Salary'] - a['Average Salary'])} layout="vertical" margin={{ top: 5, right: 30, left: 150, bottom: 5 }}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis type="number" tickFormatter={formatCurrency} />
                        <YAxis type="category" dataKey="name" width={150} tick={{ fontSize: 12 }} />
                        <Tooltip formatter={(value) => formatCurrency(value)} />
                        <Legend />
                        <Bar dataKey="Average Salary" fill="#e74c3c" />
                    </BarChart>
                </ResponsiveContainer>
            </ChartContainer>
        </div>
    );
};

const RemoteWorkAnalysis = ({ data }) => {
    const remoteData = useMemo(() => {
        const remoteMapping = { 0: 'On-site', 50: 'Hybrid', 100: 'Fully Remote' };
        const result = { 
            'On-site': { count: 0, totalSalary: 0 }, 
            'Hybrid': { count: 0, totalSalary: 0 }, 
            'Fully Remote': { count: 0, totalSalary: 0 } 
        };
        
        data.forEach(d => {
            if (d.remote_ratio === null || d.remote_ratio === undefined || !d.salary_usd) return;
            const type = remoteMapping[d.remote_ratio];
            if (type) {
                result[type].count++;
                result[type].totalSalary += d.salary_usd;
            }
        });
        
        const chartData = Object.entries(result).map(([name, values]) => ({
            name,
            value: values.count,
            avgSalary: values.count > 0 ? Math.round(values.totalSalary / values.count) : 0
        }));

        const metrics = {
            'On-site': chartData.find(d => d.name === 'On-site')?.avgSalary || 0,
            'Hybrid': chartData.find(d => d.name === 'Hybrid')?.avgSalary || 0,
            'Fully Remote': chartData.find(d => d.name === 'Fully Remote')?.avgSalary || 0,
        };
        
        return { chartData, metrics };
    }, [data]);

     return (
        <div className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <Card title="Avg. On-site Salary" value={formatCurrency(remoteData.metrics['On-site'])} />
                <Card title="Avg. Hybrid Salary" value={formatCurrency(remoteData.metrics['Hybrid'])} />
                <Card title="Avg. Fully Remote Salary" value={formatCurrency(remoteData.metrics['Fully Remote'])} />
            </div>
            <ChartContainer title="Job Distribution by Work Setting">
                <ResponsiveContainer width="100%" height="100%">
                    <PieChart>
                        <Pie 
                            data={remoteData.chartData} 
                            cx="50%" 
                            cy="50%" 
                            labelLine={false} 
                            label={({ name, percent, value }) => `${name}: ${(percent * 100).toFixed(0)}% (${value.toLocaleString()})`}
                            outerRadius={150} 
                            fill="#8884d8" 
                            dataKey="value"
                        >
                            {remoteData.chartData.map((entry, index) => (
                                <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                            ))}
                        </Pie>
                        <Tooltip formatter={(value, name, props) => {
                            const { payload } = props;
                            return [`${value.toLocaleString()} Jobs`, `Avg Salary: ${formatCurrency(payload.avgSalary)}`];
                        }}/>
                        <Legend />
                    </PieChart>
                </ResponsiveContainer>
            </ChartContainer>
        </div>
    );
};

const SkillsDemandAnalysis = ({ data }) => {
    const skillsCount = useMemo(() => {
        const counts = new Map();
        data.forEach(d => {
            if (d.required_skills) {
                 try {
                    // This handles formats like "['Python', 'SQL']"
                    const skills = JSON.parse(d.required_skills.replace(/'/g, '"'));
                    if (Array.isArray(skills)) {
                        skills.forEach(skill => counts.set(skill, (counts.get(skill) || 0) + 1));
                    }
                } catch (e) {
                    // This handles "Python, SQL, R"
                    const skills = d.required_skills.split(',').map(s => s.trim());
                    skills.forEach(skill => {
                         if (skill) counts.set(skill, (counts.get(skill) || 0) + 1);
                    });
                }
            }
        });
        return Array.from(counts.entries()).map(([name, value]) => ({ name, value })).sort((a,b) => b.value - a.value).slice(0, 15);
    }, [data]);

    return (
        <ChartContainer title="Top 15 Most In-Demand Skills">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={skillsCount} layout="vertical" margin={{ top: 5, right: 30, left: 80, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis type="number" />
                    <YAxis type="category" dataKey="name" width={100} tick={{fontSize: 12}} />
                    <Tooltip formatter={(value) => value.toLocaleString()}/>
                    <Legend />
                    <Bar dataKey="value" name="Times Mentioned" fill="#ff7300" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const JobCategoryAnalysis = ({ data }) => {
    const categoryData = useMemo(() => {
        const result = {};
        data.forEach(d => {
            // More robust check for valid job_category and salary
            if (d.job_category && d.job_category !== 'N/A' && d.salary_usd > 0) {
                const category = d.job_category;
                if (!result[category]) result[category] = { totalSalary: 0, count: 0 };
                result[category].totalSalary += d.salary_usd;
                result[category].count++;
            }
        });

        const filteredResults = Object.entries(result)
            .filter(([name, { count }]) => count > 5); // Ensure category has enough data points

        return filteredResults.map(([name, values]) => ({ 
            name, 
            'Average Salary': Math.round(values.totalSalary / values.count),
            'Job Count': values.count,
        })).sort((a,b) => b['Average Salary'] - a['Average Salary']);
    }, [data]);
    
    if (categoryData.length === 0) {
        return (
             <div className="bg-white p-8 rounded-lg shadow-md flex flex-col items-center justify-center h-full text-center">
                 <BarChart2 className="w-16 h-16 text-gray-300 mb-4" />
                 <h2 className="text-xl font-bold text-gray-700 mb-2">No Job Category Data to Display</h2>
                 <p className="text-gray-500">
                     Could not find enough data to build this chart. This might mean the 'job_category' field in the source data is either missing, empty, or doesn't have enough entries to analyze.
                 </p>
             </div>
        )
    }
    
    return (
        <ChartContainer title="Job Categories Analysis (by Avg Salary)">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={categoryData} layout="vertical" margin={{ top: 5, right: 30, left: 150, bottom: 5 }}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis type="number" tickFormatter={formatCurrency} />
                    <YAxis type="category" dataKey="name" width={150} tick={{ fontSize: 12 }} />
                    <Tooltip 
                        formatter={(value, name, props) => {
                            const { payload } = props;
                            if (name === 'Average Salary') {
                               return [`${formatCurrency(value)} (Jobs: ${payload['Job Count'].toLocaleString()})`, 'Avg Salary'];
                            }
                            return [value, name];
                        }} 
                    />
                    <Legend />
                    <Bar dataKey="Average Salary" fill="#387908" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const SalaryVsYearsExperience = ({ data }) => {
    const scatterData = useMemo(() => {
        return data
            .filter(d => d.salary_usd && d.years_experience && d.salary_usd < 400000 && d.years_experience <= 20) // Filter outliers
            .map(d => ({
                experience: d.years_experience,
                salary: d.salary_usd,
                title: d.job_title
            }));
    }, [data]);

    return (
        <ChartContainer title="Salary vs. Years of Experience">
             <ResponsiveContainer width="100%" height="100%">
                <ScatterChart margin={{ top: 20, right: 20, bottom: 20, left: 20 }}>
                    <CartesianGrid />
                    <XAxis type="number" dataKey="experience" name="Years of Experience" unit=" yrs" domain={[0, 'dataMax + 2']}/>
                    <YAxis type="number" dataKey="salary" name="Salary (USD)" tickFormatter={formatCurrency} />
                    <Tooltip cursor={{ strokeDasharray: '3 3' }} formatter={(value, name, props) => {
                        if (name === 'salary') return [formatCurrency(value), `Salary (${props.payload.title})`];
                        if (name === 'experience') return [value, 'Years of Experience'];
                        return [value, name];
                    }}/>
                    <Scatter name="Jobs" data={scatterData} fill="#8884d8" opacity={0.6}/>
                </ScatterChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const JobDescLengthAnalysis = ({ data }) => {
    const scatterData = useMemo(() => {
        return data
            .filter(d => d.job_description_length && d.salary_usd && d.experience_level_full !== 'Unknown' && d.salary_usd < 500000) // Filter outliers
            .map(d => ({
                length: d.job_description_length,
                salary: d.salary_usd,
                level: d.experience_level_full,
                title: d.job_title
            }));
    }, [data]);

    const CustomTooltip = ({ active, payload }) => {
        if (active && payload && payload.length) {
            const data = payload[0].payload;
            return (
                <div className="bg-white p-4 border border-gray-300 rounded-md shadow-lg">
                    <p className="font-bold text-gray-800">{data.title}</p>
                    <p className="text-sm text-gray-600">Experience: <span style={{color: EXP_COLORS[data.level]}}>{data.level}</span></p>
                    <p className="text-sm text-gray-600">Salary: {formatCurrency(data.salary)}</p>
                    <p className="text-sm text-gray-600">Description Length: {data.length.toLocaleString()} chars</p>
                </div>
            );
        }
        return null;
    };
    
    return (
        <div className="space-y-6">
            <div className="bg-white p-4 rounded-lg shadow-md">
                <h3 className="text-md font-semibold text-gray-700">Analysis Summary</h3>
                <p className="text-sm text-gray-600 mt-2">
                    This chart explores the relationship between the length of a job description and the offered salary, color-coded by experience level.
                    While not a perfect correlation, we can observe general trends. Longer, more detailed job descriptions may sometimes be associated with higher-level or more specialized roles, which in turn command higher salaries. However, many other factors influence salary, so this is just one piece of the puzzle.
                </p>
            </div>
            <ChartContainer title="Salary vs. Job Description Length">
                <ResponsiveContainer width="100%" height="100%">
                    <ScatterChart
                        margin={{ top: 20, right: 30, bottom: 20, left: 30 }}
                    >
                        <CartesianGrid />
                        <XAxis type="number" dataKey="length" name="Description Length" unit=" chars" domain={[0, 'dataMax + 1000']} tickFormatter={(val) => `${(val/1000).toFixed(1)}k`}/>
                        <YAxis type="number" dataKey="salary" name="Salary (USD)" tickFormatter={formatCurrency} domain={[0, 'dataMax + 20000']} />
                        <ZAxis dataKey="level" name="Experience Level" />
                        <Tooltip content={<CustomTooltip />} cursor={{ strokeDasharray: '3 3' }} />
                        <Legend />
                        {Object.keys(experienceOrder).map(level => (
                             <Scatter key={level} name={level} data={scatterData.filter(d => d.level === level)} fill={EXP_COLORS[level]} opacity={0.7} />
                        ))}
                    </ScatterChart>
                </ResponsiveContainer>
            </ChartContainer>
        </div>
    );
};

const BenefitsAnalysis = ({ data }) => {
    const benefitsData = useMemo(() => {
        const result = {};
        data.forEach(d => {
            if (!d.experience_level_full || !d.benefits_score) return;
            const level = d.experience_level_full;
            if (!result[level]) {
                result[level] = { totalScore: 0, count: 0 };
            }
            result[level].totalScore += d.benefits_score;
            result[level].count++;
        });

        return Object.entries(result).map(([name, { totalScore, count }]) => ({
            name,
            'Average Benefits Score': (totalScore / count).toFixed(2),
        })).sort((a,b) => experienceOrder[a.name] - experienceOrder[b.name]);
    }, [data]);

    return (
        <ChartContainer title="Average Benefits Score by Experience Level">
            <ResponsiveContainer width="100%" height="100%">
                <BarChart data={benefitsData}>
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis dataKey="name" />
                    <YAxis domain={[0, 10]} />
                    <Tooltip />
                    <Legend />
                    <Bar dataKey="Average Benefits Score" fill="#2ecc71" />
                </BarChart>
            </ResponsiveContainer>
        </ChartContainer>
    );
};

const AboutDataset = () => {
    const columns = [
      { key: "job_id", desc: "Unique identifier for each job posting", type: "String" },
      { key: "job_title", desc: "Standardized job title", type: "String" },
      { key: "salary_usd", desc: "Annual salary in USD", type: "Integer" },
      { key: "salary_currency", desc: "Original salary currency", type: "String" },
      { key: "salary_local", desc: "Salary in local currency", type: "Float" },
      { key: "experience_level", desc: "EN (Entry), MI (Mid), SE (Senior), EX (Executive)", type: "String" },
      { key: "employment_type", desc: "FT (Full-time), PT (Part-time), CT (Contract), FL (Freelance)", type: "String" },
      { key: "job_category", desc: "ML Engineer, Data Scientist, AI Researcher, etc.", type: "String" },
      { key: "company_location", desc: "Country where company is located", type: "String" },
      { key: "company_size", desc: "S (<50), M (50-250), L (>250)", type: "String" },
      { key: "employee_residence", desc: "Country where employee resides", type: "String" },
      { key: "remote_ratio", desc: "0 (No remote), 50 (Hybrid), 100 (Fully remote)", type: "Integer" },
      { key: "required_skills", desc: "Top 5 required skills", type: "String" },
      { key: "education_required", desc: "Minimum education requirement", type: "String" },
      { key: "years_experience", desc: "Required years of experience", type: "Integer" },
      { key: "industry", desc: "Industry sector of the company", type: "String" },
      { key: "posting_date", desc: "Date when job was posted", type: "Date" },
      { key: "application_deadline", desc: "Application deadline", type: "Date" },
      { key: "job_description_length", desc: "Character count of job description", type: "Integer" },
      { key: "benefits_score", desc: "Numerical score of benefits package (1-10)", type: "Float" },
    ];

    return (
        <div className="bg-white p-8 rounded-lg shadow-md space-y-6 text-gray-700">
            <div>
                <h2 className="text-2xl font-bold text-gray-800 mb-2">Global AI Job Market & Salary Trends 2025</h2>
                <p>This comprehensive dataset contains detailed information about over 15,000 AI and machine learning job positions, salaries, and market trends across different countries, experience levels, and company sizes. The data was collected between January 2024 and May 2025 from major job platforms.</p>
            </div>

            <div>
                <h3 className="text-xl font-semibold text-gray-800 mb-3">Columns Description</h3>
                <div className="overflow-x-auto">
                    <table className="min-w-full divide-y divide-gray-200">
                        <thead className="bg-gray-50">
                            <tr>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Column</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Type</th>
                            </tr>
                        </thead>
                        <tbody className="bg-white divide-y divide-gray-200">
                            {columns.map(col => (
                                <tr key={col.key}>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{col.key}</td>
                                    <td className="px-6 py-4 whitespace-normal text-sm text-gray-500">{col.desc}</td>
                                    <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{col.type}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    )
};


const About = () => (
    <div className="bg-white p-6 rounded-lg shadow-md max-w-4xl mx-auto">
        <h2 className="text-2xl font-bold mb-4 text-gray-800">About This App</h2>
        <p className="mb-4 text-gray-600">This dashboard provides an interactive visualization of the AI job market. It is built to demonstrate data processing, analysis, and visualization skills using modern web technologies.</p>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <h3 className="text-lg font-semibold text-gray-700 mb-2">Technology Stack</h3>
                <ul className="list-disc list-inside text-gray-600">
                    <li><strong>React:</strong> For building the user interface.</li>
                    <li><strong>Recharts:</strong> For creating interactive and responsive charts.</li>
                    <li><strong>Tailwind CSS:</strong> For rapid, utility-first styling.</li>
                    <li><strong>Lucide React:</strong> For clean and simple icons.</li>
                </ul>
            </div>
            <div>
                <h3 className="text-lg font-semibold text-gray-700 mb-2">Data Source</h3>
                <p className="text-gray-600">
                    The data is fetched live from a CSV file hosted on GitHub. It is parsed and processed entirely in the browser.
                </p>
                <p className="text-sm text-gray-500 mt-2">Note: The dataset may have inconsistencies or missing values which can affect some of the aggregations.</p>
            </div>
        </div>
    </div>
);
