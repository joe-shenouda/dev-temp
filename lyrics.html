<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LyricQuest</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      body {
        font-family: 'Inter', sans-serif;
      }
    </style>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client"
  }
}
</script>
</head>
  <body class="bg-gray-900 text-white">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
      import ReactDOM from 'react-dom/client';

      // =============================================
      // ICONS
      // =============================================
      const SearchIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
          </svg>
      );
      const MusicIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2z" />
          </svg>
      );
      const UploadIcon = () => (
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
          </svg>
      );
      const PlayIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
      const PauseIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>;
      const ResetIcon = () => <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h5M20 20v-5h-5" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 9a9 9 0 0114.13-6.36M20 15a9 9 0 01-14.13 6.36" /></svg>;

      // =============================================
      // SERVICES (lrclibService.ts)
      // =============================================
      const BASE_URL = 'https://lrclib.net';
      const USER_AGENT = 'LyricQuest/1.0.0 (https://github.com/your-repo)';

      async function handleResponse(response) {
          if (!response.ok) {
              const errorData = await response.json().catch(() => ({ message: 'An unknown error occurred' }));
              throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
          }
          return response.json();
      }
      async function searchLyrics(params) {
          const query = new URLSearchParams();
          if (params.q) query.set('q', params.q);
          if (params.track_name) query.set('track_name', params.track_name);
          if (params.artist_name) query.set('artist_name', params.artist_name);
          if (params.album_name) query.set('album_name', params.album_name);

          const response = await fetch(`${BASE_URL}/api/search?${query.toString()}`, {
              headers: { 'User-Agent': USER_AGENT },
          });
          return handleResponse(response);
      }
      async function getLyricsBySignature(params, cached) {
          const endpoint = cached ? '/api/get-cached' : '/api/get';
          const query = new URLSearchParams({
              track_name: params.track_name,
              artist_name: params.artist_name,
              album_name: params.album_name,
              duration: String(params.duration),
          });
          const response = await fetch(`${BASE_URL}${endpoint}?${query.toString()}`, {
              headers: { 'User-Agent': USER_AGENT },
          });
          return handleResponse(response);
      }
      async function getLyricsById(id) {
          const response = await fetch(`${BASE_URL}/api/get/${id}`, {
              headers: { 'User-Agent': USER_AGENT },
          });
          return handleResponse(response);
      }
      async function requestChallenge() {
          const response = await fetch(`${BASE_URL}/api/request-challenge`, {
              method: 'POST',
              headers: { 'User-Agent': USER_AGENT },
          });
          return handleResponse(response);
      }
      async function publishLyrics(data, token) {
          const response = await fetch(`${BASE_URL}/api/publish`, {
              method: 'POST',
              headers: {
                  'Content-Type': 'application/json',
                  'X-Publish-Token': token,
                  'User-Agent': USER_AGENT,
              },
              body: JSON.stringify(data),
          });
          if (response.status !== 201) {
             const errorData = await response.json().catch(() => ({ message: 'An unknown error occurred' }));
              throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
          }
          return response;
      }

      // =============================================
      // COMPONENTS
      // =============================================
      const Loader = ({small = false}) => {
          const size = small ? 'h-5 w-5' : 'h-8 w-8';
          return (
              <div className="flex justify-center items-center p-4">
                  <svg
                      className={`animate-spin text-teal-500 ${size}`}
                      xmlns="http://www.w3.org/2000/svg"
                      fill="none"
                      viewBox="0 0 24 24"
                  >
                      <circle
                          className="opacity-25"
                          cx="12"
                          cy="12"
                          r="10"
                          stroke="currentColor"
                          strokeWidth="4"
                      ></circle>
                      <path
                          className="opacity-75"
                          fill="currentColor"
                          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                      ></path>
                  </svg>
              </div>
          );
      };

      const parseLyrics = (syncedLyrics) => {
          if (!syncedLyrics) {
              return [];
          }
          const lines = syncedLyrics.split('\n');
          const parsed = [];
          const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;

          lines.forEach(line => {
              const match = line.match(timeRegex);
              if (match) {
                  const minutes = parseInt(match[1], 10);
                  const seconds = parseInt(match[2], 10);
                  const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                  const time = minutes * 60 + seconds + milliseconds / 1000;
                  const text = line.replace(timeRegex, '').trim();
                  if (text) {
                      parsed.push({ time, text });
                  }
              }
          });
          return parsed.sort((a, b) => a.time - b.time);
      };

      const useLyricsScroller = (lyrics, isPlaying, currentTime, containerRef) => {
          const [activeLineIndex, setActiveLineIndex] = useState(-1);

          useEffect(() => {
              if (!isPlaying || !lyrics.length) return;
              
              let currentIndex = -1;
              for (let i = lyrics.length - 1; i >= 0; i--) {
                  if (currentTime >= lyrics[i].time) {
                      currentIndex = i;
                      break;
                  }
              }
              setActiveLineIndex(currentIndex);

          }, [currentTime, isPlaying, lyrics]);

          useEffect(() => {
              if (activeLineIndex > -1 && containerRef.current) {
                  const activeElement = containerRef.current.children[activeLineIndex];
                  if (activeElement) {
                      const containerHeight = containerRef.current.clientHeight;
                      const elementTop = activeElement.offsetTop;
                      const elementHeight = activeElement.clientHeight;
                      
                      containerRef.current.scrollTo({
                          top: elementTop - containerHeight / 2 + elementHeight / 2,
                          behavior: 'smooth'
                      });
                  }
              }
          }, [activeLineIndex, containerRef]);

          return activeLineIndex;
      };

      const LyricsCard = ({ record }) => {
          const [view, setView] = useState('plain');
          const parsedLyrics = useMemo(() => parseLyrics(record.syncedLyrics), [record.syncedLyrics]);

          const [isPlaying, setIsPlaying] = useState(false);
          const [currentTime, setCurrentTime] = useState(0);
          const timerRef = useRef(null);
          const lyricsContainerRef = useRef(null);

          const activeLineIndex = useLyricsScroller(parsedLyrics, isPlaying, currentTime, lyricsContainerRef);

          const startTimer = useCallback(() => {
              const startTime = Date.now() - currentTime * 1000;
              timerRef.current = window.setInterval(() => {
                  const elapsed = (Date.now() - startTime) / 1000;
                  if (elapsed > record.duration) {
                      setIsPlaying(false);
                      setCurrentTime(record.duration);
                      if (timerRef.current) clearInterval(timerRef.current);
                  } else {
                      setCurrentTime(elapsed);
                  }
              }, 100);
          }, [currentTime, record.duration]);

          const stopTimer = useCallback(() => {
              if (timerRef.current) {
                  clearInterval(timerRef.current);
                  timerRef.current = null;
              }
          }, []);

          useEffect(() => {
              if (isPlaying) {
                  startTimer();
              } else {
                  stopTimer();
              }
              return () => stopTimer();
          }, [isPlaying, startTimer, stopTimer]);
          
          const handlePlayPause = () => {
              setIsPlaying(!isPlaying);
          };

          const handleReset = () => {
              setIsPlaying(false);
              setCurrentTime(0);
          };

          const formatTime = (seconds) => {
              const mins = Math.floor(seconds / 60);
              const secs = Math.floor(seconds % 60);
              return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
          };

          return (
              <div className="bg-slate-800/70 border border-slate-700 rounded-xl shadow-lg p-6">
                  <h3 className="text-2xl font-bold text-teal-400">{record.trackName}</h3>
                  <p className="text-slate-300 text-lg">{record.artistName}</p>
                  <p className="text-slate-400 text-sm mb-4">{record.albumName} ({formatTime(record.duration)})</p>

                  <div className="flex space-x-2 border-b border-slate-700 mb-4">
                      <button onClick={() => setView('plain')} className={`px-4 py-2 text-sm font-medium transition ${view === 'plain' ? 'text-teal-400 border-b-2 border-teal-400' : 'text-slate-400'}`}>Plain</button>
                      <button onClick={() => setView('synced')} className={`px-4 py-2 text-sm font-medium transition ${view === 'synced' ? 'text-teal-400 border-b-2 border-teal-400' : 'text-slate-400'}`} disabled={!record.syncedLyrics}>Synced</button>
                  </div>
                  
                  {view === 'plain' && (
                      <pre className="whitespace-pre-wrap text-slate-200 bg-slate-900/50 p-4 rounded-lg font-sans max-h-96 overflow-y-auto">{record.plainLyrics || 'No plain lyrics available.'}</pre>
                  )}

                  {view === 'synced' && (
                      <div>
                           <div ref={lyricsContainerRef} className="relative text-slate-300 text-center text-lg font-medium bg-slate-900/50 p-4 rounded-lg h-80 overflow-y-auto scroll-smooth">
                              {parsedLyrics.length > 0 ? parsedLyrics.map((line, index) => (
                                 <p key={index} className={`transition-all duration-300 py-2 ${index === activeLineIndex ? 'text-teal-300 scale-110 font-bold' : 'text-slate-400'}`}>{line.text}</p>
                              )) : <p>No synced lyrics available.</p>}
                          </div>
                          {parsedLyrics.length > 0 && (
                             <div className="mt-4 p-2 bg-slate-700/50 rounded-lg flex items-center space-x-4">
                                 <button onClick={handlePlayPause} className="text-slate-200 hover:text-teal-400 transition">
                                     {isPlaying ? <PauseIcon /> : <PlayIcon />}
                                 </button>
                                 <button onClick={handleReset} className="text-slate-200 hover:text-teal-400 transition">
                                      <ResetIcon />
                                 </button>
                                 <div className="flex-grow bg-slate-600 rounded-full h-2">
                                     <div className="bg-teal-500 h-2 rounded-full" style={{ width: `${(currentTime / record.duration) * 100}%` }}></div>
                                 </div>
                                 <span className="text-sm font-mono text-slate-300">{formatTime(currentTime)} / {formatTime(record.duration)}</span>
                             </div>
                          )}
                      </div>
                  )}
              </div>
          );
      };

      const LyricsDisplay = ({ results }) => {
          return (
              <div className="space-y-6">
                  {results.map(record => (
                      <LyricsCard key={record.id} record={record} />
                  ))}
              </div>
          );
      };

      const solveChallenge = async (prefix, target, onProgress) => {
          let nonce = 0;
          const encoder = new TextEncoder();

          while (true) {
              const data = encoder.encode(prefix + nonce);
              const hashBuffer = await crypto.subtle.digest('SHA-256', data);
              const hashArray = Array.from(new Uint8Array(hashBuffer));
              const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

              if (hashHex < target) {
                  return nonce;
              }
              nonce++;
              if (nonce % 1000 === 0) {
                  onProgress(nonce);
                  await new Promise(resolve => setTimeout(resolve, 0));
              }
          }
      };
      
      const ActionButton = ({ children, onClick, type = 'submit', disabled = false }) => (
        <button
            type={type}
            onClick={onClick}
            disabled={disabled}
            className="w-full bg-teal-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-teal-700 transition-colors duration-200 disabled:bg-slate-600 disabled:cursor-not-allowed flex items-center justify-center"
        >
            {children}
        </button>
      );

      const InputField = (props) => (
        <input
            {...props}
            className="w-full bg-slate-700/50 border border-slate-600 text-slate-100 rounded-lg px-4 py-2.5 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition"
        />
      );

      const TextAreaField = (props) => (
        <textarea
            {...props}
            className="w-full bg-slate-700/50 border border-slate-600 text-slate-100 rounded-lg px-4 py-2.5 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-teal-500 transition resize-y"
        />
      );

      const PublishForm = () => {
          const [formData, setFormData] = useState({
              trackName: '',
              artistName: '',
              albumName: '',
              duration: 0,
              plainLyrics: '',
              syncedLyrics: ''
          });
          const [status, setStatus] = useState('');
          const [error, setError] = useState(null);
          const [isLoading, setIsLoading] = useState(false);

          const handleChange = (e) => {
              const { name, value } = e.target;
              setFormData(prev => ({ ...prev, [name]: name === 'duration' ? Number(value) : value }));
          };

          const handleSubmit = async (e) => {
              e.preventDefault();
              setIsLoading(true);
              setError(null);
              setStatus('');

              try {
                  setStatus('Requesting publish challenge...');
                  const challenge = await requestChallenge();

                  setStatus('Solving challenge... This may take a moment.');
                  const nonce = await solveChallenge(challenge.prefix, challenge.target, (currentNonce) => {
                      setStatus(`Solving challenge... (nonce: ${currentNonce})`);
                  });

                  const token = `${challenge.prefix}:${nonce}`;
                  setStatus('Publishing lyrics...');

                  await publishLyrics(formData, token);
                  setStatus('Successfully published lyrics!');
                  setFormData({ trackName: '', artistName: '', albumName: '', duration: 0, plainLyrics: '', syncedLyrics: '' });
              } catch (err) {
                  setError(err.message || 'An unexpected error occurred during publishing.');
                  setStatus('');
              } finally {
                  setIsLoading(false);
              }
          };

          return (
              <form onSubmit={handleSubmit} className="space-y-4">
                  <h2 className="text-xl font-semibold text-center mb-4">Publish New Lyrics</h2>
                  <InputField name="trackName" placeholder="Track Name" value={formData.trackName} onChange={handleChange} required />
                  <InputField name="artistName" placeholder="Artist Name" value={formData.artistName} onChange={handleChange} required />
                  <InputField name="albumName" placeholder="Album Name" value={formData.albumName} onChange={handleChange} required />
                  <InputField name="duration" type="number" placeholder="Duration (seconds)" value={formData.duration || ''} onChange={handleChange} required />
                  <TextAreaField name="plainLyrics" placeholder="Plain lyrics..." value={formData.plainLyrics} onChange={handleChange} rows={5} />
                  <TextAreaField name="syncedLyrics" placeholder="Synced lyrics (e.g., [00:12.34]...)" value={formData.syncedLyrics} onChange={handleChange} rows={5} />
                  
                  <ActionButton disabled={isLoading}>
                      {isLoading ? <Loader small={true}/> : 'Publish'}
                  </ActionButton>
                  
                  {status && !error && <div className="text-center text-teal-400 mt-4">{status}</div>}
                  {error && <div className="text-center text-red-400 mt-4">{error}</div>}
              </form>
          );
      };
      
      // =============================================
      // APP ROOT COMPONENT
      // =============================================
      const TabButton = ({ icon, label, isActive, onClick }) => (
          <button
              onClick={onClick}
              className={`flex items-center space-x-2 px-3 sm:px-5 py-2.5 rounded-lg text-sm font-medium transition-all duration-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800 focus:ring-teal-500 ${
                  isActive ? 'bg-teal-600 text-white shadow-lg' : 'text-slate-300 hover:bg-slate-700/50 hover:text-white'
              }`}
          >
              {icon}
              <span className="hidden sm:inline">{label}</span>
          </button>
      );

      const SearchForm = ({ onSearch }) => {
          const [params, setParams] = useState({ q: '', track_name: '', artist_name: '', album_name: '' });

          const handleChange = (e) => {
              setParams({ ...params, [e.target.name]: e.target.value });
          };

          const handleSubmit = (e) => {
              e.preventDefault();
              onSearch(params);
          };

          return (
              <form onSubmit={handleSubmit} className="space-y-4">
                  <h2 className="text-xl font-semibold text-center mb-4">Search for Lyrics</h2>
                  <InputField name="q" placeholder="Keywords (e.g., still alive portal)" value={params.q} onChange={handleChange} />
                  <div className="text-center text-slate-400">OR</div>
                  <InputField name="track_name" placeholder="Track Name" value={params.track_name} onChange={handleChange} />
                  <InputField name="artist_name" placeholder="Artist Name (optional)" value={params.artist_name} onChange={handleChange} />
                  <InputField name="album_name" placeholder="Album Name (optional)" value={params.album_name} onChange={handleChange} />
                  <ActionButton>Search</ActionButton>
              </form>
          );
      };

      const GetForms = ({ onGetBySignature, onGetById }) => {
          const [sigParams, setSigParams] = useState({ track_name: '', artist_name: '', album_name: '', duration: 0 });
          const [id, setId] = useState('');
          const [cached, setCached] = useState(false);

          const handleSigChange = (e) => {
              const { name, value } = e.target;
              setSigParams({ ...sigParams, [name]: name === 'duration' ? Number(value) : value });
          };

          const handleSigSubmit = (e) => {
              e.preventDefault();
              onGetBySignature(sigParams, cached);
          };
          
          const handleIdSubmit = (e) => {
              e.preventDefault();
              onGetById(id);
          };

          return (
              <div className="space-y-8">
                  <form onSubmit={handleSigSubmit} className="space-y-4">
                      <h2 className="text-xl font-semibold text-center">Get by Track Signature</h2>
                      <InputField name="track_name" placeholder="Track Name" value={sigParams.track_name} onChange={handleSigChange} required />
                      <InputField name="artist_name" placeholder="Artist Name" value={sigParams.artist_name} onChange={handleSigChange} required />
                      <InputField name="album_name" placeholder="Album Name" value={sigParams.album_name} onChange={handleSigChange} required />
                      <InputField name="duration" type="number" placeholder="Duration (seconds)" value={sigParams.duration || ''} onChange={handleSigChange} required />
                      <div className="flex items-center justify-center space-x-2 text-slate-300">
                          <input type="checkbox" id="cached" name="cached" checked={cached} onChange={e => setCached(e.target.checked)} className="h-4 w-4 rounded border-slate-600 bg-slate-700 text-teal-500 focus:ring-teal-500" />
                          <label htmlFor="cached">Use cache only</label>
                      </div>
                      <ActionButton>Get by Signature</ActionButton>
                  </form>
                  <hr className="border-slate-700" />
                  <form onSubmit={handleIdSubmit} className="space-y-4">
                       <h2 className="text-xl font-semibold text-center">Get by LRCLIB ID</h2>
                      <InputField name="id" placeholder="Lyrics ID (e.g., 3396226)" value={id} onChange={e => setId(e.target.value)} required />
                      <ActionButton>Get by ID</ActionButton>
                  </form>
              </div>
          );
      };


      const App = () => {
          const [activeTab, setActiveTab] = useState('search');
          const [results, setResults] = useState(null);
          const [isLoading, setIsLoading] = useState(false);
          const [error, setError] = useState(null);

          const handleSearch = useCallback(async (params) => {
              if (!params.q && !params.track_name) {
                  setError('Please provide a general query or a track name.');
                  return;
              }
              setIsLoading(true);
              setError(null);
              setResults(null);
              try {
                  const data = await searchLyrics(params);
                  setResults(data);
                   if (data.length === 0) {
                      setError('No lyrics found for your query.');
                  }
              } catch (err) {
                  setError('Failed to fetch search results. Please try again.');
              } finally {
                  setIsLoading(false);
              }
          }, []);

          const handleGetBySignature = useCallback(async (params, cached) => {
              setIsLoading(true);
              setError(null);
              setResults(null);
              try {
                  const data = await getLyricsBySignature(params, cached);
                  setResults([data]);
              } catch (err) {
                  setError('Failed to find the specified track. Check the details and try again.');
              } finally {
                  setIsLoading(false);
              }
          }, []);

          const handleGetById = useCallback(async (id) => {
              if (!id || isNaN(Number(id))) {
                  setError('Please enter a valid numeric ID.');
                  return;
              }
              setIsLoading(true);
              setError(null);
              setResults(null);
              try {
                  const data = await getLyricsById(Number(id));
                  setResults([data]);
              } catch (err) {
                  setError('Failed to find a track with that ID.');
              } finally {
                  setIsLoading(false);
              }
          }, []);

          return (
              <div className="min-h-screen bg-gradient-to-br from-gray-900 to-slate-800 text-slate-100 p-4 sm:p-6 lg:p-8">
                  <div className="max-w-4xl mx-auto">
                      <header className="text-center mb-8">
                          <h1 className="text-4xl sm:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-blue-500">
                              LyricQuest
                          </h1>
                          <p className="text-slate-400 mt-2">Your gateway to the world of lyrics.</p>
                      </header>

                      <main className="bg-slate-800/50 backdrop-blur-sm border border-slate-700 rounded-xl shadow-2xl overflow-hidden">
                          <div className="p-5 border-b border-slate-700">
                              <nav className="flex justify-center space-x-2 sm:space-x-4">
                                  <TabButton
                                      icon={<SearchIcon />}
                                      label="Search"
                                      isActive={activeTab === 'search'}
                                      onClick={() => setActiveTab('search')}
                                  />
                                  <TabButton
                                      icon={<MusicIcon />}
                                      label="Get"
                                      isActive={activeTab === 'get'}
                                      onClick={() => setActiveTab('get')}
                                  />
                                  <TabButton
                                      icon={<UploadIcon />}
                                      label="Publish"
                                      isActive={activeTab === 'publish'}
                                      onClick={() => setActiveTab('publish')}
                                  />
                              </nav>
                          </div>

                          <div className="p-5 sm:p-8">
                              {activeTab === 'search' && <SearchForm onSearch={handleSearch} />}
                              {activeTab === 'get' && <GetForms onGetBySignature={handleGetBySignature} onGetById={handleGetById} />}
                              {activeTab === 'publish' && <PublishForm />}
                          </div>
                      </main>

                      <div className="mt-8">
                          {isLoading && <Loader />}
                          {error && <div className="text-center text-red-400 bg-red-900/50 p-4 rounded-lg">{error}</div>}
                          {results && <LyricsDisplay results={results} />}
                      </div>
                       <footer className="text-center mt-12 text-slate-500 text-sm">
                          <p>Powered by the LRCLIB API. Built with React and Tailwind CSS.</p>
                      </footer>
                  </div>
              </div>
          );
      };
      
      // =============================================
      // RENDER THE APP
      // =============================================
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>
